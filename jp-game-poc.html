<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JP Lesson Adventure - Proof of Concept</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500;700;900&family=Poppins:wght@500;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --indoor: linear-gradient(135deg, #fef9f6, #f2e9e4);
      --outdoor: linear-gradient(135deg, #e3f2fd, #e8fff6);
      --school: linear-gradient(135deg, #f5f7ff, #eef2ff);
      --panel: #10141a;
      --accent: #f05454;
      --primary: #4e54c8;
      --bubble: #ffffff;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Poppins', 'Noto Sans JP', sans-serif;
      background: radial-gradient(circle at 10% 10%, #f1f2f6, #dfe6e9 40%, #eef2ff);
      color: #1e272e;
      display: flex;
      justify-content: center;
      padding: 20px;
    }

    .shell {
      width: min(1100px, 100%);
      background: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 24px 60px rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.04);
    }

    header {
      background: linear-gradient(120deg, #4e54c8, #8f94fb);
      color: white;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    header h1 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.02em;
    }

    header small {
      opacity: 0.85;
      font-weight: 600;
    }

    .layout {
      display: grid;
      grid-template-columns: 3fr 2fr;
      gap: 0;
    }

    .stage {
      background: #0f172a;
      position: relative;
    }

    canvas { display: block; margin: 0 auto; background: #152030; }

    .hud {
      padding: 14px 16px;
      background: #0f172a;
      color: #cbd5e1;
      border-top: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .hud span strong { color: #fff; }

    .side-panel {
      background: #0b1020;
      color: #dfe6e9;
      display: flex;
      flex-direction: column;
      gap: 18px;
      padding: 20px;
    }

    .card {
      background: #11182d;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 14px 16px;
      box-shadow: 0 14px 30px rgba(0,0,0,0.2);
    }

    .card h2 { margin: 0 0 8px; font-size: 1.05rem; color: #fff; }
    .card p { margin: 4px 0; line-height: 1.4; color: #cbd5e1; }

    .legend { display: flex; flex-wrap: wrap; gap: 10px; }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(255,255,255,0.04);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 0.9rem;
    }
    .dot { width: 14px; height: 14px; border-radius: 4px; }

    .cta-btn {
      background: #4e54c8;
      color: white;
      border: none;
      padding: 12px 14px;
      border-radius: 10px;
      font-weight: 800;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(78,84,200,0.25);
      width: 100%;
    }

    .dialogue-shell {
      position: absolute;
      inset: auto 14px 14px 14px;
      pointer-events: none;
    }

    .dialogue {
      display: none;
      align-items: center;
      gap: 16px;
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.08);
    }

    .dialogue.show { display: flex; }

    .dialogue .bg {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      opacity: 0.9;
      filter: saturate(1.1);
      z-index: 0;
    }

    .dialogue .photo {
      width: 110px;
      height: 110px;
      border-radius: 10px;
      background: #fff;
      overflow: hidden;
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dialogue .photo img { width: 100%; height: 100%; object-fit: cover; }

    .dialogue .bubble {
      background: var(--bubble);
      padding: 12px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.12);
      position: relative;
      z-index: 1;
      max-width: 500px;
    }

    .dialogue .bubble::after {
      content: '';
      position: absolute;
      left: -10px;
      top: 20px;
      border-width: 10px;
      border-style: solid;
      border-color: transparent var(--bubble) transparent transparent;
    }

    .bubble h3 { margin: 0 0 6px; color: #11182d; }
    .bubble p { margin: 0; color: #2d3436; line-height: 1.45; font-size: 0.98rem; }
    .bubble .jp { font-family: 'Noto Sans JP'; font-weight: 700; display: block; margin-bottom: 4px; color: #4e54c8; }

    .prompt {
      position: absolute;
      left: 50%;
      top: 12px;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.9);
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 700;
      box-shadow: 0 12px 24px rgba(0,0,0,0.35);
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div>
        <h1>JP Lesson Adventure (Proof of Concept)</h1>
        <small>Move with arrow keys/WASD. Walk up to family members and press Space/Enter to chat.</small>
      </div>
      <button class="cta-btn" id="reset-btn">Reset Scene</button>
    </header>
    <div class="layout">
      <div class="stage">
        <div class="prompt">Walk into someone then press Space/Enter to talk</div>
        <canvas id="world" width="800" height="520"></canvas>
        <div class="dialogue-shell">
          <div class="dialogue" id="dialogue">
            <div class="bg" id="dialogue-bg"></div>
            <div class="photo"><img id="dialogue-portrait" alt="portrait" /></div>
            <div class="bubble">
              <h3 id="dialogue-name"></h3>
              <span class="jp" id="dialogue-jp"></span>
              <p id="dialogue-en"></p>
            </div>
          </div>
        </div>
      </div>
      <aside class="side-panel">
        <div class="card">
          <h2>How this works</h2>
          <p>This prototype uses your sprites as actors in a tiny overworld. Each colored zone has its own backdrop and vocabulary focus.</p>
          <p>When two characters stand close and you press <strong>Space</strong> or <strong>Enter</strong>, the location background, portrait, and a bilingual speech bubble appear.</p>
        </div>
        <div class="card">
          <h2>Legend & Controls</h2>
          <div class="legend">
            <span class="tag"><span class="dot" style="background: #1f2937"></span>Indoor</span>
            <span class="tag"><span class="dot" style="background: #18544d"></span>Park</span>
            <span class="tag"><span class="dot" style="background: #35468c"></span>School</span>
            <span class="tag"><span class="dot" style="background: #f05454"></span>Interact</span>
          </div>
          <p>Move: WASD / Arrow keys</p>
          <p>Talk: Space or Enter</p>
          <p>Next line: Space / Enter again</p>
        </div>
        <div class="card">
          <h2>NPC Focus Points</h2>
          <p><strong>Mom:</strong> Greetings & home vocabulary.</p>
          <p><strong>Dad:</strong> Directions around the park.</p>
          <p><strong>You:</strong> Responds with simple acknowledgements.</p>
        </div>
        <div class="card">
          <h2>Art asset usage</h2>
          <p id="asset-sprites">Sprites: loading…</p>
          <p id="asset-map">Map: loading…</p>
          <p id="asset-dialogue">Dialogue bg: loading…</p>
          <p id="asset-portraits">Portraits: loading…</p>
        </div>
      </aside>
    </div>
    <div class="hud">
      <span>Location: <strong id="hud-location">–</strong></span>
      <span>Nearest partner: <strong id="hud-partner">None</strong></span>
      <span>Hint: <strong id="hud-hint">Walk up to a family member.</strong></span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const hudLocation = document.getElementById('hud-location');
    const hudPartner = document.getElementById('hud-partner');
    const hudHint = document.getElementById('hud-hint');

    const assetSpriteStatus = document.getElementById('asset-sprites');
    const assetMapStatus = document.getElementById('asset-map');
    const assetDialogueStatus = document.getElementById('asset-dialogue');
    const assetPortraitStatus = document.getElementById('asset-portraits');

    const dialogueEl = document.getElementById('dialogue');
    const dialogueBg = document.getElementById('dialogue-bg');
    const dialoguePortrait = document.getElementById('dialogue-portrait');
    const dialogueName = document.getElementById('dialogue-name');
    const dialogueJp = document.getElementById('dialogue-jp');
    const dialogueEn = document.getElementById('dialogue-en');

    const TILE = 64;
    const MAP_W = Math.floor(canvas.width / TILE);
    const MAP_H = Math.floor(canvas.height / TILE);

    const zones = {
      indoor: { color: '#1f2937', background: 'var(--indoor)', name: 'Home' },
      park: { color: '#18544d', background: 'var(--outdoor)', name: 'Park' },
      school: { color: '#35468c', background: 'var(--school)', name: 'School Gate' }
    };

    const map = [
      ['park','park','park','park','park','park','park','park','school','school','school','school'],
      ['park','park','park','park','park','park','park','park','school','school','school','school'],
      ['park','park','park','park','park','park','park','park','school','school','school','school'],
      ['indoor','indoor','indoor','indoor','indoor','indoor','park','park','school','school','school','school'],
      ['indoor','indoor','indoor','indoor','indoor','indoor','park','park','school','school','school','school'],
      ['indoor','indoor','indoor','indoor','indoor','indoor','park','park','park','park','park','park'],
      ['indoor','indoor','indoor','indoor','indoor','indoor','park','park','park','park','park','park'],
      ['indoor','indoor','indoor','indoor','indoor','indoor','park','park','park','park','park','park']
    ];

    const sprites = {
      player: createSprite('mesprite.png'),
      mom: createSprite('momsprite.png'),
      dad: createSprite('dadsprite.png')
    };

    const portraits = {
      mom: 'mom-convo.png',
      dad: 'dad-convo.png',
      player: 'me-convo.png'
    };

    const dialogueBackdrops = {
      indoor: 'mom-convo.png',
      park: 'dad-convo.png',
      school: 'me-convo.png'
    };

    const mapTexture = loadOptionalImage('map.png');
    const portraitImages = {};
    const backdropImages = {
      indoor: loadOptionalImage(dialogueBackdrops.indoor),
      park: loadOptionalImage(dialogueBackdrops.park),
      school: loadOptionalImage(dialogueBackdrops.school)
    };

    Object.entries(portraits).forEach(([key, src]) => {
      portraitImages[key] = loadOptionalImage(src);
    });

    refreshAssetStatus();

    function loadOptionalImage(src) {
      const holder = { src, ok: false, img: new Image() };
      holder.img.onload = () => { holder.ok = true; refreshAssetStatus(); };
      holder.img.onerror = () => { holder.ok = false; refreshAssetStatus(); };
      holder.img.src = src;
      return holder;
    }

    function createSprite(src) {
      const targetHeight = TILE * 0.9;
      const sprite = { img: new Image(), scale: 1, natural: { w: 0, h: 0 }, loaded: false };
      sprite.img.onload = () => {
        sprite.loaded = true;
        sprite.natural = { w: sprite.img.width, h: sprite.img.height };
        sprite.scale = targetHeight / sprite.img.height;
        refreshAssetStatus();
      };
      sprite.img.onerror = () => { sprite.loaded = false; refreshAssetStatus(); };
      sprite.img.src = src;
      return sprite;
    }

    const actors = [
      {
        id: 'player',
        name: 'You',
        x: 2 * TILE,
        y: 4 * TILE,
        speed: 3,
        sprite: sprites.player,
        facing: 'down'
      },
      {
        id: 'mom',
        name: 'Mom',
        x: 5 * TILE,
        y: 3 * TILE,
        sprite: sprites.mom,
        facing: 'left',
        talkScript: [
          { jp: 'おかえり！今日はどうだった？', en: 'Welcome home! How was your day?', speaker: 'mom' },
          { jp: '疲れたけど、頑張ったよ。', en: 'Tiring, but I did my best.', speaker: 'player' },
          { jp: 'じゃあ、先に手を洗ってから夕飯にしましょう。', en: 'Great! Wash your hands first and then let\'s have dinner.', speaker: 'mom' }
        ]
      },
      {
        id: 'dad',
        name: 'Dad',
        x: 8 * TILE,
        y: 1 * TILE,
        sprite: sprites.dad,
        facing: 'right',
        talkScript: [
          { jp: '公園の噴水まで競争しようか？', en: 'Race you to the fountain?', speaker: 'dad' },
          { jp: 'いいよ！でも道を教えてね。', en: 'Sure! But you have to show me the way.', speaker: 'player' },
          { jp: 'まっすぐ行って左だよ。いくよ、さん、に、いち！', en: 'Go straight and turn left. Ready? Three, two, one!', speaker: 'dad' }
        ]
      }
    ];

    const player = actors.find(a => a.id === 'player');
    const inputs = { up:false, down:false, left:false, right:false };
    let talkingTo = null;
    let talkIndex = 0;

    function keyChange(e, isDown) {
      if (['ArrowUp','w','W'].includes(e.key)) inputs.up = isDown;
      if (['ArrowDown','s','S'].includes(e.key)) inputs.down = isDown;
      if (['ArrowLeft','a','A'].includes(e.key)) inputs.left = isDown;
      if (['ArrowRight','d','D'].includes(e.key)) inputs.right = isDown;

      if (isDown && [' ','Enter'].includes(e.key)) {
        if (talkingTo) {
          advanceConversation();
        } else {
          tryStartConversation();
        }
        e.preventDefault();
      }
    }

    window.addEventListener('keydown', e => keyChange(e, true));
    window.addEventListener('keyup', e => keyChange(e, false));

    document.getElementById('reset-btn').onclick = resetScene;

    function resetScene() {
      player.x = 2 * TILE; player.y = 4 * TILE;
      actors.find(a => a.id === 'mom').x = 5 * TILE;
      actors.find(a => a.id === 'mom').y = 3 * TILE;
      actors.find(a => a.id === 'dad').x = 8 * TILE;
      actors.find(a => a.id === 'dad').y = 1 * TILE;
      closeDialogue();
    }

    function tryStartConversation() {
      const partner = findNearestPartner();
      if (!partner || partner.dist > 70) return;
      talkingTo = partner.actor;
      talkIndex = 0;
      showDialogueLine();
    }

    function advanceConversation() {
      talkIndex += 1;
      const script = talkingTo.talkScript || [];
      if (talkIndex >= script.length) {
        closeDialogue();
        return;
      }
      showDialogueLine();
    }

    function closeDialogue() {
      talkingTo = null;
      talkIndex = 0;
      dialogueEl.classList.remove('show');
    }

    function showDialogueLine() {
      const script = talkingTo.talkScript || [];
      const line = script[talkIndex];
      if (!line) { closeDialogue(); return; }
      const speakerId = line.speaker;
      const speaker = actors.find(a => a.id === speakerId) || player;
      const portrait = portraits[speakerId] || portraits.player;

      setDialogueBackground(getCurrentZone(player.x, player.y));
      dialoguePortrait.src = portrait;
      dialogueName.textContent = speakerId === 'player' ? 'You' : speaker.name;
      dialogueJp.textContent = line.jp;
      dialogueEn.textContent = line.en;
      dialogueEl.classList.add('show');
    }

    function getCurrentZone(x, y) {
      const gx = Math.floor(x / TILE);
      const gy = Math.floor(y / TILE);
      const row = map[gy];
      if (!row) return 'park';
      return row[gx] || 'park';
    }

    function setDialogueBackground(zoneKey) {
      const backdrop = backdropImages[zoneKey];
      if (backdrop && backdrop.ok) {
        dialogueBg.style.backgroundImage = `url(${backdrop.src})`;
        dialogueBg.style.backgroundSize = 'cover';
      } else {
        dialogueBg.style.backgroundImage = zones[zoneKey]?.background || zones.park.background;
        dialogueBg.style.backgroundSize = 'auto';
      }
    }

    function findNearestPartner() {
      let closest = { actor:null, dist: Infinity };
      actors.forEach(actor => {
        if (actor.id === 'player') return;
        const dx = actor.x - player.x;
        const dy = actor.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < closest.dist) closest = { actor, dist };
      });
      return closest;
    }

    function refreshAssetStatus() {
      const loadedSprites = Object.values(sprites).filter(s => s.loaded).length;
      const spriteDetails = Object.entries(sprites).map(([key, s]) => {
        if (!s.loaded) return `${key}: loading`;
        const scaledH = Math.round(s.natural.h * s.scale);
        return `${key}: ${s.natural.w}x${s.natural.h} → ${Math.round(s.natural.w * s.scale)}x${scaledH}`;
      }).join('; ');
      assetSpriteStatus.textContent = `Sprites: ${loadedSprites}/${Object.keys(sprites).length} ready${spriteDetails ? ` (${spriteDetails})` : ''}`;

      if (mapTexture.ok) {
        assetMapStatus.textContent = `Map: ${mapTexture.src} (${mapTexture.img.width}x${mapTexture.img.height}) scaled to ${canvas.width}x${canvas.height}`;
      } else {
        assetMapStatus.textContent = 'Map: not found (using color zones)';
      }

      const loadedPortraits = Object.values(portraitImages).filter(p => p.ok).length;
      assetPortraitStatus.textContent = `Portraits: ${loadedPortraits}/${Object.keys(portraits).length} ready`;

      const readyBackdrops = Object.values(backdropImages).filter(b => b && b.ok).length;
      assetDialogueStatus.textContent = readyBackdrops ? `Dialogue bg: using portrait art (${readyBackdrops}/3 loaded)` : 'Dialogue bg: using location gradients';
    }

    function update(dt) {
      if (!talkingTo) movePlayer(dt);
    }

    function movePlayer(dt) {
      const speed = player.speed * (dt / 16);
      let vx = 0, vy = 0;
      if (inputs.up) vy -= speed;
      if (inputs.down) vy += speed;
      if (inputs.left) vx -= speed;
      if (inputs.right) vx += speed;

      player.x = clamp(player.x + vx, 0, canvas.width - TILE);
      player.y = clamp(player.y + vy, 0, canvas.height - TILE);
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function draw() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawMap();
      drawActors();
      updateHud();
      requestAnimationFrame(draw);
    }

    function drawMap() {
      if (mapTexture.ok) {
        ctx.drawImage(mapTexture.img, 0, 0, canvas.width, canvas.height);
        return;
      }
      for (let y=0; y<MAP_H; y++) {
        for (let x=0; x<MAP_W; x++) {
          const zone = zones[map[y][x]] || zones.park;
          ctx.fillStyle = zone.color;
          ctx.fillRect(x*TILE, y*TILE, TILE-2, TILE-2);
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.fillRect(x*TILE+6, y*TILE+6, TILE-12, TILE-12);
        }
      }
    }

    function drawActors() {
      actors.forEach(actor => {
        const { img, scale } = actor.sprite;
        const w = img.width * scale;
        const h = img.height * scale;
        const drawX = actor.x + TILE/2 - w/2;
        const drawY = actor.y + TILE - h + 8;
        if (img.complete) ctx.drawImage(img, drawX, drawY, w, h);
        else img.onload = () => ctx.drawImage(img, drawX, drawY, w, h);

        if (talkingTo && talkingTo.id === actor.id) {
          drawSpeechFlag(actor);
        }
      });
    }

    function drawSpeechFlag(actor) {
      const bubbleX = actor.x + TILE/2 - 24;
      const bubbleY = actor.y - 6;
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.strokeStyle = '#f05454';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(bubbleX, bubbleY, 48, 32, 8);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#f05454';
      ctx.font = 'bold 16px Poppins';
      ctx.fillText('…', bubbleX + 15, bubbleY + 21);
    }

    function updateHud() {
      const zoneKey = getCurrentZone(player.x, player.y);
      hudLocation.textContent = zones[zoneKey].name;
      const partner = findNearestPartner();
      hudPartner.textContent = partner.actor ? `${partner.actor.name} (${Math.round(partner.dist)}px)` : 'None';
      hudHint.textContent = talkingTo ? 'Press Space/Enter for next line or to finish.' : 'Walk up to a family member.';
      setDialogueBackground(zoneKey);
    }

    let last = 0;
    function loop(timestamp) {
      const dt = timestamp - last;
      last = timestamp;
      update(dt);
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(draw);
    requestAnimationFrame(loop);
  </script>
</body>
</html>

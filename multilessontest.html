<div id="jp-lesson-root">Waiting for script...</div>
<script>
(function () {
  // --- CONFIGURATION ---
  const REPO_CONFIG = {
    owner: "gryswynd",
    repo: "jp-lessons",
    branch: "main",
    path: ""
  };

  const rootId = "jp-lesson-root";
  const root = document.getElementById(rootId);
  if (!root) return;

  // --- State ---
  let currentStep = 0;
  let totalSteps = 0;
  let lessonData = null;
  let termMapData = {};
  let derivedSurfaceMap = {};
  let showEN = false;

  // --- Styles ---
  const style = document.createElement("style");
  style.textContent = `
    #${rootId} {
      --primary: #4e54c8; --primary-dark: #3f44a5;
      --bg-grad: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      --text-main: #2f3542; --text-sub: #747d8c;
      font-family: 'Poppins', 'Noto Sans JP', sans-serif;
      color: var(--text-main); background: var(--bg-grad);
      border-radius: 18px; overflow: hidden; max-width: 820px; margin: 0 auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.08);
      position: relative; min-height: 600px; display: flex; flex-direction: column;
    }
    #${rootId} .jp-header {
      background: #fff; padding: 15px 20px; border-bottom: 1px solid rgba(0,0,0,0.05);
      display: flex; align-items: center; justify-content: space-between;
    }
    #${rootId} .jp-title { font-weight: 900; font-size: 1.1rem; color: var(--primary); }
    #${rootId} .jp-progress-container { height: 6px; width: 100%; background: #eee; }
    #${rootId} .jp-progress-bar { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s ease; }
    #${rootId} .jp-body { padding: 20px; flex: 1; overflow-y: auto; }
    #${rootId} .jp-footer {
      padding: 15px 20px; background: #fff; border-top: 1px solid rgba(0,0,0,0.05);
      display: flex; gap: 10px; justify-content: space-between;
    }
    #${rootId} .jp-nav-btn {
      padding: 10px 20px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer;
    }
    #${rootId} .jp-nav-btn.prev { background: #f1f2f6; color: var(--text-sub); }
    #${rootId} .jp-nav-btn.next { background: var(--primary); color: #fff; box-shadow: 0 4px 10px rgba(78,84,200,0.3); }
    #${rootId} .jp-nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* MENU STYLES */
    #${rootId} .jp-menu-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }
    #${rootId} .jp-menu-item {
        background: #fff; padding: 20px; border-radius: 12px; cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.05); transition: transform 0.2s, box-shadow 0.2s;
        border: 2px solid transparent; text-align: center;
    }
    #${rootId} .jp-menu-item:hover { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(78,84,200,0.15); border-color: var(--primary); }
    #${rootId} .jp-menu-id { font-weight: 900; color: var(--primary); font-size: 1.2rem; margin-bottom: 5px; }
    #${rootId} .jp-menu-name { font-size: 0.9rem; color: var(--text-sub); }
    #${rootId} .jp-back-btn { background: transparent; color: var(--text-sub); border: none; cursor: pointer; font-weight: bold; font-size: 0.9rem; }
    #${rootId} .jp-back-btn:hover { color: var(--primary); }

    /* UPDATED: Renamed class to 'jp-speaker-bubble' to avoid conflicts */
    #${rootId} .jp-speaker-bubble {
      background: #f1f2f6; color: var(--primary-dark); font-weight: 900;
      width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
      border-radius: 8px; flex-shrink: 0;
    }

    #${rootId} .jp-card { background: #fff; border-radius: 16px; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.03); margin-bottom: 15px; }
    #${rootId} .jp-intro-card { text-align: center; padding: 40px 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; }
    #${rootId} .jp-intro-title { font-size: 2rem; color: var(--primary); margin-bottom: 20px; line-height: 1.2; }
    #${rootId} .jp-intro-focus { font-size: 1.1rem; color: var(--text-sub); margin-bottom: 40px; background: #f8f9fa; padding: 15px 25px; border-radius: 50px; display: inline-block; }
    #${rootId} .jp-intro-kanji-row { font-size: 2.5rem; font-weight: 900; color: var(--text-main); display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    #${rootId} .jp-intro-dot { color: var(--primary); opacity: 0.4; }
    #${rootId} .jp-row { display: flex; gap: 12px; margin-bottom: 15px; align-items: flex-start; }
    #${rootId} .jp-jp { font-size: 1.2rem; line-height: 1.6; font-family: 'Noto Sans JP', sans-serif; }
    #${rootId} .jp-en { font-size: 0.9rem; color: var(--text-sub); margin-top: 4px; display: none; }
    #${rootId} .jp-term { color: var(--primary); font-weight: 700; cursor: pointer; border-bottom: 2px solid rgba(78,84,200,0.1); transition: 0.2s; }
    #${rootId} .jp-term:hover { background: rgba(78,84,200,0.05); border-bottom-color: var(--primary); }
    #${rootId} .jp-form-label { font-size: 0.75rem; color: var(--text-sub); margin-left: 4px; font-weight: 700; }
    #${rootId} .jp-toggle-en { font-size: 0.8rem; font-weight: 700; color: var(--text-sub); background: #f1f2f6; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; margin-bottom: 15px; }
    #${rootId} .jp-kanji-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; }
    #${rootId} .jp-flip-container { perspective: 1000px; cursor: pointer; height: 180px; }
    #${rootId} .jp-flip-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; border-radius: 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
    #${rootId} .jp-flip-container.flipped .jp-flip-inner { transform: rotateY(180deg); }
    #${rootId} .jp-flip-front, #${rootId} .jp-flip-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #fff; border-radius: 16px; border: 1px solid rgba(0,0,0,0.05); }
    #${rootId} .jp-flip-front { z-index: 2; }
    #${rootId} .jp-flip-back { transform: rotateY(180deg); background: #fdfdfd; padding: 10px; }
    #${rootId} .jp-k-char { font-size: 3.5rem; font-weight: 900; color: var(--text-main); line-height: 1; }
    #${rootId} .jp-k-sub { font-size: 0.9rem; color: var(--text-sub); margin-top: 8px; font-weight: 600; }
    #${rootId} .jp-k-readings { font-size: 0.85rem; color: var(--text-main); margin-bottom: 5px; }
    #${rootId} .jp-k-meaning { font-size: 0.95rem; font-weight: 800; color: var(--primary); }

    .jp-modal-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); z-index: 999999; display: none; align-items: center; justify-content: center; }
    .jp-modal { background: #fff; width: 90%; max-width: 500px; border-radius: 20px; padding: 25px; box-shadow: 0 25px 50px rgba(0,0,0,0.25); position: relative; }
    .jp-close-btn { position: absolute; top: 15px; right: 15px; background: #f1f2f6; border: none; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-weight: bold; }
    #${rootId} .jp-mcq-opt { display: block; width: 100%; text-align: left; padding: 12px 15px; margin-bottom: 8px; background: #fff; border: 2px solid #eee; border-radius: 12px; cursor: pointer; font-weight: 600; }
    #${rootId} .jp-mcq-opt.correct { background: #d4edda; border-color: #c3e6cb; }
    #${rootId} .jp-mcq-opt.wrong { background: #f8d7da; border-color: #f5c6cb; }
  `;
  document.head.appendChild(style);

  // --- Helpers ---
  function el(tag, cls, inner) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (inner !== undefined) {
      if(typeof inner === 'string') e.innerHTML = inner;
      else e.appendChild(inner);
    }
    return e;
  }
  function esc(s) { return String(s || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); }
  function getCdnUrl(filename) {
    // Use raw.githubusercontent.com for immediate updates during development
    return `https://raw.githubusercontent.com/${REPO_CONFIG.owner}/${REPO_CONFIG.repo}/${REPO_CONFIG.branch}/${REPO_CONFIG.path ? REPO_CONFIG.path + '/' : ''}${filename}`;
  }

  // --- Master Glossary (cached) ---
  const MASTER_GLOSSARY_FILE = "glossary.master.json";
  let masterGlossaryPromise = null;

  const CONJUGATION_FORMS = [
    { formKey: "masu", label: "„Åæ„Åô", meaningSuffix: " (polite)" },
    { formKey: "nai", label: "„Å™„ÅÑ", meaningSuffix: " (negative)" },
    { formKey: "ta", label: "„Åü", meaningSuffix: " (past)" },
    { formKey: "te", label: "„Å¶", meaningSuffix: " (te-form)" },
    { formKey: "mashou", label: "„Åæ„Åó„Çá„ÅÜ", meaningSuffix: " (let's/volitional)" }
  ];

  const CONJUGATION_FORM_MAP = CONJUGATION_FORMS.reduce((acc, rule) => {
    acc[rule.formKey] = rule;
    return acc;
  }, {});

  const GODAN_MAP = {
    "„ÅÜ": { masu: "„ÅÑ", nai: "„Çè", ta: "„Å£", te: "„Å£", mashou: "„Åä" },
    "„Åè": { masu: "„Åç", nai: "„Åã", ta: "„ÅÑ", te: "„ÅÑ", mashou: "„Åì" },
    "„Åê": { masu: "„Åé", nai: "„Åå", ta: "„ÅÑ", te: "„ÅÑ", mashou: "„Åî" },
    "„Åô": { masu: "„Åó", nai: "„Åï", ta: "„Åó", te: "„Åó", mashou: "„Åù" },
    "„Å§": { masu: "„Å°", nai: "„Åü", ta: "„Å£", te: "„Å£", mashou: "„Å®" },
    "„Å¨": { masu: "„Å´", nai: "„Å™", ta: "„Çì", te: "„Çì", mashou: "„ÅÆ" },
    "„Å∂": { masu: "„Å≥", nai: "„Å∞", ta: "„Çì", te: "„Çì", mashou: "„Åº" },
    "„ÇÄ": { masu: "„Åø", nai: "„Åæ", ta: "„Çì", te: "„Çì", mashou: "„ÇÇ" },
    "„Çã": { masu: "„Çä", nai: "„Çâ", ta: "„Å£", te: "„Å£", mashou: "„Çç" }
  };

  const ICHIDAN_MARKERS = new Set([
    "„ÅÑ", "„Åç", "„Åé", "„Åó", "„Åò", "„Å°", "„Å¢", "„Å´", "„Å≤", "„Å≥", "„Å¥", "„Åø", "„Çä",
    "„Åà", "„Åë", "„Åí", "„Åõ", "„Åú", "„Å¶", "„Åß", "„Å≠", "„Å∏", "„Åπ", "„Å∫", "„ÇÅ", "„Çå"
  ]);

  function isVerbTerm(term) {
    return term && (term.gtype === "verb" || term.type === "verb");
  }

  function getVerbClass(term) {
    if (!isVerbTerm(term)) return null;
    const surface = term.surface || "";
    const reading = term.reading || surface;
    if (!surface) return null;
    if (surface.endsWith("„Åô„Çã") || reading.endsWith("„Åô„Çã")) return "suru";
    if (surface.endsWith("„Åè„Çã") || surface.endsWith("Êù•„Çã") || reading.endsWith("„Åè„Çã")) return "kuru";
    if (reading.endsWith("„Çã")) {
      const before = reading.slice(-2, -1);
      if (ICHIDAN_MARKERS.has(before)) return "ichidan";
    }
    return "godan";
  }

  function conjugateVerb(term) {
    if (!isVerbTerm(term)) return [];
    const surface = term.surface || "";
    if (!surface) return [];
    const verbClass = getVerbClass(term);
    if (!verbClass) return [];

    const forms = [];
    if (verbClass === "suru") {
      const stem = surface.replace(/„Åô„Çã$/, "");
      forms.push(
        { surface: `${stem}„Åó„Åæ„Åô`, formKey: "masu", meaningSuffix: CONJUGATION_FORM_MAP.masu.meaningSuffix },
        { surface: `${stem}„Åó„Å™„ÅÑ`, formKey: "nai", meaningSuffix: CONJUGATION_FORM_MAP.nai.meaningSuffix },
        { surface: `${stem}„Åó„Åü`, formKey: "ta", meaningSuffix: CONJUGATION_FORM_MAP.ta.meaningSuffix },
        { surface: `${stem}„Åó„Å¶`, formKey: "te", meaningSuffix: CONJUGATION_FORM_MAP.te.meaningSuffix },
        { surface: `${stem}„Åó„Åæ„Åó„Çá„ÅÜ`, formKey: "mashou", meaningSuffix: CONJUGATION_FORM_MAP.mashou.meaningSuffix }
      );
      return forms;
    }

    if (verbClass === "kuru") {
      const stem = surface.replace(/„Çã$/, "");
      forms.push(
        { surface: `${stem}„Åç„Åæ„Åô`, formKey: "masu", meaningSuffix: CONJUGATION_FORM_MAP.masu.meaningSuffix },
        { surface: `${stem}„Åì„Å™„ÅÑ`, formKey: "nai", meaningSuffix: CONJUGATION_FORM_MAP.nai.meaningSuffix },
        { surface: `${stem}„Åç„Åü`, formKey: "ta", meaningSuffix: CONJUGATION_FORM_MAP.ta.meaningSuffix },
        { surface: `${stem}„Åç„Å¶`, formKey: "te", meaningSuffix: CONJUGATION_FORM_MAP.te.meaningSuffix },
        { surface: `${stem}„Åç„Åæ„Åó„Çá„ÅÜ`, formKey: "mashou", meaningSuffix: CONJUGATION_FORM_MAP.mashou.meaningSuffix }
      );
      return forms;
    }

    const stemSurface = surface.slice(0, -1);
    const lastChar = surface.slice(-1);

    if (verbClass === "ichidan") {
      forms.push(
        { surface: `${stemSurface}„Åæ„Åô`, formKey: "masu", meaningSuffix: CONJUGATION_FORM_MAP.masu.meaningSuffix },
        { surface: `${stemSurface}„Å™„ÅÑ`, formKey: "nai", meaningSuffix: CONJUGATION_FORM_MAP.nai.meaningSuffix },
        { surface: `${stemSurface}„Åü`, formKey: "ta", meaningSuffix: CONJUGATION_FORM_MAP.ta.meaningSuffix },
        { surface: `${stemSurface}„Å¶`, formKey: "te", meaningSuffix: CONJUGATION_FORM_MAP.te.meaningSuffix },
        { surface: `${stemSurface}„Åæ„Åó„Çá„ÅÜ`, formKey: "mashou", meaningSuffix: CONJUGATION_FORM_MAP.mashou.meaningSuffix }
      );
      return forms;
    }

    const godanRule = GODAN_MAP[lastChar];
    if (!godanRule) return forms;

    forms.push(
      { surface: `${stemSurface}${godanRule.masu}„Åæ„Åô`, formKey: "masu", meaningSuffix: CONJUGATION_FORM_MAP.masu.meaningSuffix },
      { surface: `${stemSurface}${godanRule.nai}„Å™„ÅÑ`, formKey: "nai", meaningSuffix: CONJUGATION_FORM_MAP.nai.meaningSuffix },
      { surface: `${stemSurface}${godanRule.ta}„Åü`, formKey: "ta", meaningSuffix: CONJUGATION_FORM_MAP.ta.meaningSuffix },
      { surface: `${stemSurface}${godanRule.te}„Å¶`, formKey: "te", meaningSuffix: CONJUGATION_FORM_MAP.te.meaningSuffix },
      { surface: `${stemSurface}${godanRule.mashou}„Åæ„Åó„Çá„ÅÜ`, formKey: "mashou", meaningSuffix: CONJUGATION_FORM_MAP.mashou.meaningSuffix }
    );

    return forms;
  }

  async function loadMasterGlossaryMap() {
    if (!masterGlossaryPromise) {
      masterGlossaryPromise = fetch(getCdnUrl(MASTER_GLOSSARY_FILE))
        .then(r => {
          if (!r.ok) throw new Error(`Could not load master glossary (${r.status})`);
          return r.json();
        })
        .then(gloss => {
          const map = {};
          const surfaceMap = {};
          gloss.forEach(i => { map[i.id] = i; });
          gloss.forEach(term => {
            if (!isVerbTerm(term)) return;
            const forms = conjugateVerb(term);
            forms.forEach(form => {
              if (!form.surface || surfaceMap[form.surface]) return;
              surfaceMap[form.surface] = {
                baseId: term.id,
                conjugationKey: form.formKey,
                meaningSuffix: form.meaningSuffix
              };
            });
          });
          return { termMap: map, derivedSurfaceMap: surfaceMap };
        });
    }
    return masterGlossaryPromise;
  }

  // --- Text Processing ---
  function processText(text, termIds) {
    if (!text) return "";
    let html = esc(text);
    if (!termIds || termIds.length === 0) return html;
    const terms = termIds.map(id => termMapData[id]).filter(Boolean);
    const replacements = [];
    const seenSurfaces = new Set();

    terms.forEach(t => {
      if (!t.surface || seenSurfaces.has(t.surface)) return;
      seenSurfaces.add(t.surface);
      replacements.push({
        surface: t.surface,
        html: `<span class="jp-term" onclick="window.JP_OPEN_TERM('${t.id}')">${t.surface}</span>`
      });
    });

    terms.forEach(t => {
      if (!isVerbTerm(t)) return;
      const forms = conjugateVerb(t);
      forms.forEach(form => {
        if (!form.surface || seenSurfaces.has(form.surface)) return;
        seenSurfaces.add(form.surface);
        const label = CONJUGATION_FORM_MAP[form.formKey]?.label || form.formKey;
        replacements.push({
          surface: form.surface,
          html: `<span class="jp-term" onclick="window.JP_OPEN_TERM('${t.id}', '${form.formKey}')">${form.surface}<span class="jp-form-label">${label}</span></span>`
        });
      });
    });

    replacements.sort((a, b) => b.surface.length - a.surface.length);
    replacements.forEach(item => {
      html = html.split(item.surface).join(item.html);
    });
    return html;
  }

  // --- Modal ---
  let modalOverlay = document.querySelector('.jp-modal-overlay');
  if (!modalOverlay) {
    modalOverlay = el("div", "jp-modal-overlay");
    modalOverlay.innerHTML = `
      <div class="jp-modal">
        <button class="jp-close-btn">‚úï</button>
        <h2 id="jp-m-title" style="margin:0 0 5px 0; color:#4e54c8; font-family:'Noto Sans JP'"></h2>
        <div id="jp-m-meta" style="color:#747d8c; font-weight:700; margin-bottom:15px;"></div>
        <div id="jp-m-notes" style="line-height:1.5;"></div>
      </div>`;
    document.body.appendChild(modalOverlay);
    const close = () => modalOverlay.style.display = 'none';
    modalOverlay.onclick = (e) => { if(e.target === modalOverlay) close(); };
    modalOverlay.querySelector('.jp-close-btn').onclick = close;
  }
  window.JP_OPEN_TERM = function(id, formKey) {
    const t = termMapData[id];
    if (!t) return;
    const formRule = formKey ? CONJUGATION_FORM_MAP[formKey] : null;
    const meaningSuffix = formRule?.meaningSuffix || "";
    document.getElementById('jp-m-title').innerText = t.surface;
    const metaParts = [];
    if (t.reading) metaParts.push(t.reading);
    if (t.meaning) metaParts.push(`${t.meaning}${meaningSuffix}`);
    document.getElementById('jp-m-meta').innerText = metaParts.join(" ‚Ä¢ ");
    document.getElementById('jp-m-notes').innerText = t.notes || "";
    modalOverlay.style.display = 'flex';
  };

  // --- Renderers ---
  function createToggle() {
    const btn = el("button", "jp-toggle-en", showEN ? "Hide English" : "Show English");
    btn.onclick = function() { showEN = !showEN; renderCurrentStep(); };
    return btn;
  }

  function renderIntro(data) {
    const div = el("div", "jp-card jp-intro-card");
    div.appendChild(el("div", "jp-intro-title", data.title));
    if (data.meta && data.meta.focus) div.appendChild(el("div", "jp-intro-focus", `<strong>Focus:</strong> ${data.meta.focus}`));
    if (data.meta && data.meta.kanji) {
        const row = el("div", "jp-intro-kanji-row");
        data.meta.kanji.forEach((char, idx) => {
            let termId = null;
            for (const [key, val] of Object.entries(termMapData)) { if (val.surface === char && val.type === 'kanji') { termId = key; break; } }
            if (termId) { const span = el("span", "jp-term", char); span.onclick = () => window.JP_OPEN_TERM(termId); row.appendChild(span); }
            else { row.appendChild(el("span", "", char)); }
            if (idx < data.meta.kanji.length - 1) row.appendChild(el("span", "jp-intro-dot", "‚Ä¢"));
        });
        div.appendChild(row);
    }
    return div;
  }

  function renderKanjiFlip(sec) {
  const grid = el("div", "jp-kanji-grid");

  (sec.items || []).forEach(k => {
    const kanjiId =
      k.termId ||
      (k.terms || []).find(id => termMapData[id]?.type === "kanji");

    const t = kanjiId ? termMapData[kanjiId] : null;

    const kanjiChar = t?.surface || k.kanji;
    const on = (t?.on ?? k.on ?? "");
    const kun = (t?.kun ?? k.kun ?? "");
    const meaning = (t?.meaning ?? k.meaning ?? "");

    const card = el("div", "jp-flip-container");
    card.onclick = function () { this.classList.toggle("flipped"); };

    card.innerHTML = `
      <div class="jp-flip-inner">
        <div class="jp-flip-front">
          <div class="jp-k-char">${kanjiChar}</div>
          <div class="jp-k-sub">Tap to Flip</div>
        </div>
        <div class="jp-flip-back">
          <div class="jp-k-readings">
            ${on ? `ON: ${on}` : ""}<br>
            ${kun ? `KUN: ${kun}` : ""}
          </div>
          <div class="jp-k-meaning">${meaning}</div>
        </div>
      </div>`;
    grid.appendChild(card);
  });

  return grid;
}

  function renderConversation(sec) {
    const div = el("div", ""); div.appendChild(createToggle());
    (sec.lines || []).forEach(line => {
      const row = el("div", "jp-row");
      // UPDATED: Use 'jp-speaker-bubble' and add 'translate="no"'
      row.innerHTML = `<div class="jp-speaker-bubble" translate="no">${line.spk}</div><div style="flex:1"><div class="jp-jp">${processText(line.jp, line.terms)}</div><div class="jp-en" style="display:${showEN?'block':'none'}">${esc(line.en)}</div></div>`;
      div.appendChild(row);
    });
    return div;
  }

  function renderWarmup(sec) {
    const div = el("div", ""); div.appendChild(createToggle());
    (sec.items || []).forEach((item, idx) => {
      const row = el("div", "jp-row");
      // UPDATED: Use 'jp-speaker-bubble' here too
      row.innerHTML = `<div class="jp-speaker-bubble" translate="no">${idx+1}</div><div style="flex:1"><div class="jp-jp">${processText(item.jp, item.terms)}</div><div class="jp-en" style="display:${showEN?'block':'none'}">${esc(item.en)}</div></div>`;
      div.appendChild(row);
    });
    return div;
  }

  function renderReading(sec) {
    const div = el("div", ""); div.appendChild(createToggle());
    const pCard = el("div", "jp-card");
    (sec.passage || []).forEach(p => {
       pCard.appendChild(el("div", "", `<div class="jp-jp" style="margin-bottom:8px;">${processText(p.jp, p.terms)}</div><div class="jp-en" style="display:${showEN?'block':'none'}; margin-bottom:15px; color:#888;">${esc(p.en)}</div>`));
    });
    div.appendChild(pCard);
    if (sec.questions) {
      const qCard = el("div", "jp-card");
      qCard.innerHTML = `<h3 style="margin-top:0;">Questions</h3>`;
      sec.questions.forEach((q, i) => {
         const row = el("div", "jp-row");
         // UPDATED: Use 'jp-speaker-bubble' here too
         row.innerHTML = `<div class="jp-speaker-bubble" translate="no">Q${i+1}</div><div><div class="jp-jp">${processText(q.q, q.terms)}</div><div class="jp-en" style="display:${showEN?'block':'none'}">Ans: ${esc(q.a)}</div></div>`;
         qCard.appendChild(row);
      });
      div.appendChild(qCard);
    }
    return div;
  }

  function renderVocab(sec) {
    const div = el("div", "");
    (sec.groups || []).forEach(g => {
        const group = el("div", "jp-card");
        group.innerHTML = `<div style="font-weight:700; color:#888; margin-bottom:10px;">${g.label}</div>`;
        const chips = el("div", "", "");
        chips.style.cssText = "display:flex; flex-wrap:wrap; gap:8px;";
        (g.items || []).forEach(tid => {
          const t = termMapData[tid];
          if(t) {
            const chip = el("div", "", t.surface);
            chip.style.cssText = "background:#f1f2f6; padding:8px 12px; border-radius:20px; font-weight:bold; cursor:pointer;";
            chip.onclick = () => JP_OPEN_TERM(tid);
            chips.appendChild(chip);
          }
        });
        group.appendChild(chips);
        div.appendChild(group);
    });
    return div;
  }

  // Helper function to resolve root term from potentially conjugated term IDs
  function getRootTerm(termId) {
    // Try direct lookup first (handles both base terms and already-generated conjugations)
    let term = termMapData[termId];
    if (term) {
      // If it has an original_id, get the root term
      return term.original_id ? termMapData[term.original_id] : term;
    }

    // Term not found - likely a conjugated form that hasn't been generated yet
    // Try progressively removing suffix parts to find the base term
    const parts = termId.split('_');
    while (parts.length > 1) {
      parts.pop(); // Remove last segment
      const candidateId = parts.join('_');
      term = termMapData[candidateId];
      if (term) {
        // Found the base term
        return term.original_id ? termMapData[term.original_id] : term;
      }
    }

    return null; // No root term found
  }

  function renderDrills(sec) {
     const div = el("div", "");
     (sec.items || []).forEach(item => {
       if (item.kind === 'mcq') {
         const card = el("div", "jp-card");
         card.innerHTML = `<div class="jp-jp" style="margin-bottom:10px; font-weight:bold;">${processText(item.q, item.terms)}</div>`;
         const optsDiv = el("div");
         let solved = false;
         item.choices.forEach(choice => {
           const btn = el("button", "jp-mcq-opt", choice);
           btn.onclick = () => {
             if(solved) return; solved = true;
             if(choice === item.answer) btn.classList.add("correct");
             else {
               btn.classList.add("wrong");
               Array.from(optsDiv.children).forEach(c => { if(c.innerText === item.answer) c.classList.add("correct"); });

               // Auto-flag terms for review when answer is wrong
               if(item.terms && item.terms.length > 0) {
                 const flags = JSON.parse(localStorage.getItem('k-flags') || '{}');
                 const activeFlags = JSON.parse(localStorage.getItem('k-active-flags') || '{}');

                 item.terms.forEach(termId => {
                   const rootTerm = getRootTerm(termId);
                   if(rootTerm) {
                     const key = rootTerm.surface;
                     flags[key] = (flags[key] || 0) + 1;
                     activeFlags[key] = true;
                   }
                 });

                 localStorage.setItem('k-flags', JSON.stringify(flags));
                 localStorage.setItem('k-active-flags', JSON.stringify(activeFlags));
               }
             }
           };
           optsDiv.appendChild(btn);
         });
         card.appendChild(optsDiv);
         div.appendChild(card);
       }
     });
     return div;
  }

  // --- Logic ---
  async function fetchLessonList() {
    const apiUrl = `https://api.github.com/repos/${REPO_CONFIG.owner}/${REPO_CONFIG.repo}/contents/${REPO_CONFIG.path}`;
    root.innerHTML = `<div class="jp-header"><div class="jp-title">Loading Lesson List...</div></div><div class="jp-body" style="text-align:center;">Connecting to GitHub...</div>`;
    try {
      const res = await fetch(apiUrl);
      if (!res.ok) throw new Error("Failed to fetch repository contents. Rate limit may be exceeded.");
      const files = await res.json();
      const lessonFiles = files.filter(f => f.name.match(/^N\d+\.\d+\.json$/)).map(f => f.name);
      lessonFiles.sort((a, b) => {
        const partsA = a.replace('N','').replace('.json','').split('.').map(Number);
        const partsB = b.replace('N','').replace('.json','').split('.').map(Number);
        if (partsA[0] !== partsB[0]) return partsA[0] - partsB[0];
        return partsA[1] - partsB[1];
      });
      renderMenu(lessonFiles);
    } catch (err) {
      root.innerHTML = `<div class="jp-body" style="color:red; text-align:center; padding:20px;"><h3>Unable to load lessons</h3><p>${err.message}</p></div>`;
    }
  }

  function renderMenu(files) {
    if (files.length === 0) { root.innerHTML = `<div class="jp-body" style="text-align:center;">No lesson files found.</div>`; return; }
    root.innerHTML = `<div class="jp-header"><div class="jp-title">Select a Lesson</div><div style="font-size:0.8rem; color:#888;">${files.length} available</div></div><div class="jp-body"><div class="jp-menu-grid" id="jp-menu-container"></div></div>`;
    const container = document.getElementById('jp-menu-container');
    files.forEach(fileName => {
      const displayName = fileName.replace('.json', '');
      const btn = el("div", "jp-menu-item");
      btn.innerHTML = `<div class="jp-menu-id">${displayName}</div><div class="jp-menu-name">Click to Load</div>`;
      btn.onclick = () => loadLesson(fileName);
      container.appendChild(btn);
    });
  }

  async function loadLesson(fileName) {
  const lessonUrl = getCdnUrl(fileName);

  root.innerHTML = `<div class="jp-header"><button class="jp-back-btn">‚Üê Menu</button><div class="jp-title">Loading ${fileName}.</div><div style="width:40px;"></div></div><div class="jp-progress-container"><div class="jp-progress-bar"></div></div><div class="jp-body"></div><div class="jp-footer"><button class="jp-nav-btn prev">Previous</button><button class="jp-nav-btn next">Next</button></div>`;
  root.querySelector('.jp-back-btn').onclick = () => fetchLessonList();

  try {
    const [lRes, masterMap] = await Promise.all([
      fetch(lessonUrl),
      loadMasterGlossaryMap()
    ]);

    if (!lRes.ok) throw new Error(`Could not load lesson file (${lRes.status})`);

    lessonData = await lRes.json();
    termMapData = masterMap.termMap; // ‚úÖ master glossary drives everything now
    derivedSurfaceMap = masterMap.derivedSurfaceMap;

    lessonData.sections.unshift({ type: 'intro', title: lessonData.title });
    currentStep = 0; totalSteps = lessonData.sections.length; showEN = false;

    root.querySelector('.jp-nav-btn.prev').onclick = () => {
      if (currentStep > 0) { currentStep--; renderCurrentStep(); }
    };
    root.querySelector('.jp-nav-btn.next').onclick = () => {
      if (currentStep < totalSteps) { currentStep++; renderCurrentStep(); }
      else { fetchLessonList(); }
    };

    renderCurrentStep();
  } catch (err) {
    root.querySelector('.jp-body').innerHTML =
      `<div style="padding:20px; color:red;">Error loading lesson: ${err.message}</div>`;
  }
}

  function renderCurrentStep() {
    const body = root.querySelector('.jp-body');
    const title = root.querySelector('.jp-title');
    const bar = root.querySelector('.jp-progress-bar');
    const nextBtn = root.querySelector('.jp-nav-btn.next');
    body.innerHTML = ""; bar.style.width = (((currentStep + 1) / totalSteps) * 100) + "%";
    if (currentStep >= lessonData.sections.length) { title.innerText = "Summary"; body.innerHTML = `<div class="jp-card" style="text-align:center;"><h2>üéâ Lesson Complete!</h2><p>Great job.</p></div>`; nextBtn.innerText = "Back to Menu"; return; }
    const sec = lessonData.sections[currentStep];
    title.innerText = (sec.type === 'intro') ? lessonData.title : sec.title;
    const wrap = el("div");
    if(sec.instructions) wrap.appendChild(el("div", "", `<div style="margin-bottom:20px; color:#747d8c;">${sec.instructions}</div>`));
    let content = null;
    if (sec.type === "intro") content = renderIntro(lessonData);
    else if (sec.type === "kanjiGrid") content = renderKanjiFlip(sec);
    else if (sec.type === "conversation") content = renderConversation(sec);
    else if (sec.type === "vocabList") content = renderVocab(sec);
    else if (sec.type === "drills") content = renderDrills(sec);
    else if (sec.type === "warmup") content = renderWarmup(sec);
    else if (sec.type === "reading") content = renderReading(sec);
    if(content) wrap.appendChild(content); body.appendChild(wrap);
    root.querySelector('.jp-nav-btn.prev').disabled = (currentStep === 0);
    nextBtn.innerText = (currentStep === totalSteps - 1) ? "Finish" : "Next";
  }

  fetchLessonList();
})();
</script>
